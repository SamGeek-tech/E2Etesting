# Release Pipeline - Runs on release branches and tags
# Executes: Build -> Unit Tests -> Contract Tests -> E2E Tests
# Uses GitVersion (.NET Tool) with GitVersion.yml configuration

trigger:
  branches:
    include:
      - release/*
  tags:
    include:
      - v*

pool:
  vmImage: 'windows-latest'

variables:
  buildConfiguration: 'Release'
  NUGET_PACKAGES: $(Pipeline.Workspace)/.nuget/packages
  # Set this variable in pipeline settings or variable group
  E2E_BASE_URL: 'https://your-staging-app-url'

stages:
- stage: Build
  displayName: 'Build & Version'
  jobs:
  - job: Build
    displayName: 'Build Solution'
    steps:
    - checkout: self
      persistCredentials: true
      fetchDepth: 0  # Required for GitVersion to calculate version history

    - task: UseDotNet@2
      inputs:
        packageType: 'sdk'
        version: '8.x'
      displayName: 'Setup .NET 8 SDK'

    # Install and Run GitVersion using .NET Tool (reads GitVersion.yml automatically)
    - pwsh: |
        # Install GitVersion as .NET global tool
        dotnet tool install --global GitVersion.Tool --version 5.* 2>&1 | Out-Null
        $env:PATH = "$env:USERPROFILE\.dotnet\tools;$env:PATH"
        
        # Run GitVersion with explicit JSON output format
        $rawOutput = & dotnet-gitversion /output json 2>&1
        
        # Filter to get only the JSON part (skip any warning/info lines)
        $jsonLines = $rawOutput | Where-Object { $_ -match '^\s*[\{\[]' -or $_ -match '^\s*"' -or $_ -match '^\s*[\}\]]' -or $_ -match '^\s*\d' }
        $jsonString = $jsonLines -join "`n"
        
        # If filtering didn't work, try to find JSON object in output
        if (-not $jsonString -or $jsonString -notmatch '\{') {
            $jsonString = ($rawOutput | Out-String) -replace '(?s)^.*?(\{)', '$1' -replace '(\})(?s).*?$', '$1'
        }
        
        try {
            $out = $jsonString | ConvertFrom-Json
        } catch {
            Write-Host "Raw GitVersion output:"
            Write-Host $rawOutput
            Write-Host "Filtered JSON:"
            Write-Host $jsonString
            throw "Failed to parse GitVersion output: $_"
        }
        
        # Set pipeline variables for use in subsequent steps/stages
        Write-Host "##vso[task.setvariable variable=SemVer;isOutput=true]$($out.SemVer)"
        Write-Host "##vso[task.setvariable variable=AssemblySemVer;isOutput=true]$($out.AssemblySemVer)"
        Write-Host "##vso[task.setvariable variable=MajorMinorPatch;isOutput=true]$($out.MajorMinorPatch)"
        Write-Host "##vso[task.setvariable variable=NuGetVersionV2;isOutput=true]$($out.NuGetVersionV2)"
        Write-Host "##vso[task.setvariable variable=FullSemVer;isOutput=true]$($out.FullSemVer)"
        
        # Output version info
        Write-Host "=========================================="
        Write-Host "GitVersion Results (from GitVersion.yml)"
        Write-Host "=========================================="
        Write-Host "SemVer:         $($out.SemVer)"
        Write-Host "FullSemVer:     $($out.FullSemVer)"
        Write-Host "NuGetVersion:   $($out.NuGetVersionV2)"
        Write-Host "AssemblySemVer: $($out.AssemblySemVer)"
        Write-Host "Branch:         $($out.BranchName)"
        Write-Host "=========================================="
      displayName: 'Run GitVersion'
      name: gitversion

    # Update build number with semantic version
    - pwsh: |
        Write-Host "Updating build number to: $(gitversion.SemVer)"
        Write-Host "##vso[build.updatebuildnumber]$(gitversion.SemVer)"
      displayName: 'Update Build Number'

    - task: Cache@2
      inputs:
        key: 'nuget | "$(Agent.OS)" | **/*.csproj'
        restoreKeys: |
          nuget | "$(Agent.OS)"
        path: $(NUGET_PACKAGES)
      displayName: 'Cache NuGet packages'

    - script: dotnet restore
      displayName: 'Restore Dependencies'

    - script: dotnet build --configuration $(buildConfiguration) --no-restore /p:Version=$(gitversion.SemVer)
      displayName: 'Build Solution'

- template: templates/unit-tests.yml
- template: templates/integration-tests.yml
- template: templates/e2e-tests.yml

- stage: TagRelease
  displayName: 'Create Version Tag'
  dependsOn: E2ETests
  condition: succeeded()
  jobs:
  - job: Tag
    displayName: 'Tag Repository'
    steps:
    - checkout: self
      persistCredentials: true
      fetchDepth: 0

    - task: UseDotNet@2
      inputs:
        packageType: 'sdk'
        version: '8.x'
      displayName: 'Setup .NET 8 SDK'

    # Re-run GitVersion to get the version (runs fast, already cached)
    - pwsh: |
        dotnet tool install --global GitVersion.Tool --version 5.* 2>&1 | Out-Null
        $env:PATH = "$env:USERPROFILE\.dotnet\tools;$env:PATH"
        
        $rawOutput = & dotnet-gitversion /output json 2>&1
        $jsonLines = $rawOutput | Where-Object { $_ -match '^\s*[\{\[]' -or $_ -match '^\s*"' -or $_ -match '^\s*[\}\]]' -or $_ -match '^\s*\d' }
        $jsonString = $jsonLines -join "`n"
        if (-not $jsonString -or $jsonString -notmatch '\{') {
            $jsonString = ($rawOutput | Out-String) -replace '(?s)^.*?(\{)', '$1' -replace '(\})(?s).*?$', '$1'
        }
        $out = $jsonString | ConvertFrom-Json
        
        Write-Host "##vso[task.setvariable variable=SemVer]$($out.SemVer)"
        Write-Host "Version to tag: $($out.SemVer)"
      displayName: 'Get Version'
      name: version

    - pwsh: |
        git config user.email "build@company.com"
        git config user.name "Azure DevOps Pipeline"
        
        $tag = "v$(version.SemVer)"
        Write-Host "Creating tag: $tag"
        
        # Check if tag already exists
        $existingTag = git tag -l $tag
        if ($existingTag) {
          Write-Host "Tag $tag already exists, skipping"
        } else {
          git tag $tag
          git push origin $tag
          Write-Host "Tag $tag created and pushed"
        }
      displayName: 'Create and Push Tag'
