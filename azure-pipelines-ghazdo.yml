# Pipeline that triggers on Pull Request creation
# Runs code quality checks against Azure DevOps (no test execution)

trigger: none  # Don't trigger on push, only on PR

pr:
  branches:
    include:
    - '*'  # Trigger on PRs to any branch
  paths:
    exclude:
    - README.md
    - '*.md'
    - 'docs/**'

pool:
  vmImage: 'windows-latest'

variables:
  buildConfiguration: 'Release'
  NUGET_PACKAGES: $(Pipeline.Workspace)/.nuget/packages

stages:
- stage: Build
  displayName: 'üî® Build & Validate'
  jobs:
  - job: BuildJob
    displayName: 'Build Solution'
    steps:
    # - pwsh: |
    #     Write-Host "=========================================="
    #     Write-Host "üöÄ PULL REQUEST CODE VALIDATION"
    #     Write-Host "=========================================="
    #     Write-Host "Build ID: $(Build.BuildId)"
    #     Write-Host "Build Number: $(Build.BuildNumber)"
    #     Write-Host "Source Branch: $(Build.SourceBranch)"
    #     Write-Host "Source Branch Name: $(Build.SourceBranchName)"
        
    #     # Check for PR variables (available only in PR builds)
    #     # Use environment variables only - these are set by Azure DevOps for PR builds
    #     $prNumber = $env:SYSTEM_PULLREQUEST_PULLREQUESTNUMBER
    #     $prSourceBranch = $env:SYSTEM_PULLREQUEST_SOURCEBRANCH
    #     $prTargetBranch = $env:SYSTEM_PULLREQUEST_TARGETBRANCH
        
    #     if ($prNumber -and $prNumber -ne "") {
    #       Write-Host "PR Number: $prNumber"
    #       if ($prSourceBranch -and $prSourceBranch -ne "") {
    #         Write-Host "PR Source Branch: $prSourceBranch"
    #       }
    #       if ($prTargetBranch -and $prTargetBranch -ne "") {
    #         Write-Host "PR Target Branch: $prTargetBranch"
    #       }
    #     } else {
    #       Write-Host "PR Number: Not available (may be triggered manually or on push)"
    #     }
        
    #     Write-Host "Build Reason: $(Build.Reason)"
    #     Write-Host "Configuration: $(buildConfiguration)"
    #     Write-Host "Azure DevOps Organization: $(System.TeamFoundationCollectionUri)"
    #     Write-Host "Azure DevOps Project: $(System.TeamProject)"
    #     Write-Host "Repository: $(Build.Repository.Name)"
    #     Write-Host "=========================================="
    #   displayName: 'üìã PR Information'

    - task: UseDotNet@2
      inputs:
        packageType: 'sdk'
        version: '8.x'
      displayName: '‚öôÔ∏è Setup .NET 8 SDK'

    # ‚ö° CACHE: NuGet packages
    - task: Cache@2
      inputs:
        key: 'nuget | "$(Agent.OS)" | **/*.csproj'
        restoreKeys: |
          nuget | "$(Agent.OS)"
        path: $(NUGET_PACKAGES)
      displayName: '‚ö° Cache NuGet packages'

    - pwsh: |
        Write-Host "üì¶ Restoring dependencies..."
        dotnet restore --verbosity minimal
      displayName: 'üì¶ Restore Dependencies'

    - pwsh: |
        Write-Host "üî® Building solution..."
        dotnet build --configuration $(buildConfiguration) --no-restore
      displayName: 'üî® Build Solution'

    # - pwsh: |
    #     if ($LASTEXITCODE -ne 0) {
    #       Write-Host "‚ùå Build failed!"
    #       exit 1
    #     }
    #     Write-Host "‚úÖ Build succeeded"
    #   displayName: '‚úÖ Verify Build'

- stage: CodeQuality
  displayName: 'üîç Code Quality Checks (Azure DevOps)'
  dependsOn: Build
  condition: succeeded()
  jobs:
  - job: CodeQuality_Job
    displayName: 'Code Quality Validation'
    steps:
    - task: UseDotNet@2
      inputs:
        packageType: 'sdk'
        version: '8.x'
      displayName: '‚öôÔ∏è Setup .NET SDK'

    - pwsh: |
        Write-Host "=========================================="
        Write-Host "üîç CODE QUALITY CHECKS - AZURE DEVOPS"
        Write-Host "=========================================="
        Write-Host "Running code validation against Azure DevOps..."
        Write-Host "Organization: $(System.TeamFoundationCollectionUri)"
        Write-Host "Project: $(System.TeamProject)"
        Write-Host "Repository: $(Build.Repository.Name)"
        Write-Host "=========================================="
      displayName: 'üìã Code Quality Info'

    # Gitleaks - Secret Scanning Tool
    # Benefits:
    # - Detects hardcoded secrets, API keys, passwords, tokens
    # - Scans entire repository history (can detect secrets in commits)
    # - Supports 100+ secret types (AWS, Azure, GitHub, etc.)
    # - Fast and lightweight
    # - Prevents secrets from being committed to repository
    - task: Gitleaks@3
      displayName: 'üîí Gitleaks - Secret Scanning'
      inputs:
        scanMode: 'smart'
        reportFormat: 'sarif'
        sarifReportPath: '$(Build.ArtifactStagingDirectory)/gitleaks-report.sarif'
        severityThreshold: 'high'
        failOnSecrets: true
        noGit: false
        verbose: true
      continueOnError: true

    # Publish Gitleaks results to Security tab
    - task: PublishPipelineArtifact@1
      displayName: 'üìä Publish Gitleaks Scan Results'
      inputs:
        targetPath: '$(Build.ArtifactStagingDirectory)'
        artifact: 'GitleaksResults'
      condition: always()
    
    # - task: AdvancedSecurity-Codeql-Init@1
    #   displayName: Initialize CodeQL
    #   inputs:
    #     languages: 'csharp, javascript' 
    #     buildtype: 'none'

    # - task: AdvancedSecurity-Codeql-Analyze@1
    #   displayName: Perform CodeQL Analysis

    # GitHub Advanced Security - Dependency Scanning
    # - task: AdvancedSecurity-Dependency-Scanning@1
    #   displayName: 'üîí GitHub Advanced Security - Dependency Scanning'
    #   inputs:
    #     scanMode: 'all'
    #     failOnCVEs: true
    #     severityThreshold: 'high'
    #     generateSarif: true
    #     sarifOutputPath: '$(Build.ArtifactStagingDirectory)/dependency-scan-results.sarif'
    #   continueOnError: true

    # # Enhanced Dependency Scanning (complements GitHub Advanced Security)
    # - pwsh: |
    #     Write-Host "=========================================="
    #     Write-Host "üîí ENHANCED DEPENDENCY SCANNING"
    #     Write-Host "=========================================="
    #     Write-Host "Performing comprehensive dependency analysis..."
    #     Write-Host ""
        
    #     # Ensure packages are restored
    #     Write-Host "üì¶ Restoring packages for dependency analysis..."
    #     dotnet restore --verbosity quiet 2>&1 | Out-Null
        
    #     # Get all project files
    #     $projectFiles = Get-ChildItem -Path . -Filter "*.csproj" -Recurse | 
    #         Where-Object { $_.FullName -notlike "*\bin\*" -and $_.FullName -notlike "*\obj\*" }
        
    #     Write-Host "Found $($projectFiles.Count) project file(s) to analyze"
    #     Write-Host ""
        
    #     # Analyze each project
    #     $allVulnerabilities = @()
    #     $allDeprecated = @()
    #     $allOutdated = @()
        
    #     foreach ($project in $projectFiles) {
    #       $projectName = $project.Name
    #       Write-Host "Analyzing: $projectName"
          
    #       # Check for vulnerable packages
    #       $vulnOutput = dotnet list "$($project.FullName)" package --vulnerable --include-transitive 2>&1 | Out-String
    #       if ($vulnOutput -match "vulnerable|CVE") {
    #         Write-Host "  ‚ö†Ô∏è Vulnerabilities found in $projectName"
    #         $allVulnerabilities += "  Project: $projectName`n$vulnOutput"
    #       }
          
    #       # Check for deprecated packages
    #       $depOutput = dotnet list "$($project.FullName)" package --deprecated --include-transitive 2>&1 | Out-String
    #       if ($depOutput -match "deprecated") {
    #         Write-Host "  ‚ö†Ô∏è Deprecated packages in $projectName"
    #         $allDeprecated += "  Project: $projectName`n$depOutput"
    #       }
          
    #       # Check for outdated packages
    #       $outdatedOutput = dotnet list "$($project.FullName)" package --outdated --include-transitive 2>&1 | Out-String
    #       if ($outdatedOutput -match "outdated|latest") {
    #         Write-Host "  ‚ÑπÔ∏è Outdated packages in $projectName"
    #         $allOutdated += "  Project: $projectName`n$outdatedOutput"
    #       }
    #     }
        
    #     Write-Host ""
    #     Write-Host "=========================================="
    #     Write-Host "DEPENDENCY SCANNING SUMMARY"
    #     Write-Host "=========================================="
        
    #     if ($allVulnerabilities.Count -gt 0) {
    #       Write-Host "‚ùå VULNERABILITIES DETECTED:"
    #       $allVulnerabilities | ForEach-Object { Write-Host $_ }
    #       Write-Host ""
    #     }
        
    #     if ($allDeprecated.Count -gt 0) {
    #       Write-Host "‚ö†Ô∏è DEPRECATED PACKAGES:"
    #       $allDeprecated | ForEach-Object { Write-Host $_ }
    #       Write-Host ""
    #     }
        
    #     if ($allOutdated.Count -gt 0) {
    #       Write-Host "‚ÑπÔ∏è OUTDATED PACKAGES (consider updating):"
    #       $allOutdated | ForEach-Object { Write-Host $_ }
    #       Write-Host ""
    #     }
        
    #     if ($allVulnerabilities.Count -eq 0 -and $allDeprecated.Count -eq 0) {
    #       Write-Host "‚úÖ No critical dependency issues found"
    #     }
        
    #     Write-Host "=========================================="
    #   displayName: 'üîí Enhanced Dependency Scanning'
    #   continueOnError: true

    # Publish dependency scan results (if GitHub Advanced Security task created SARIF)
    # - task: PublishSecurityAnalysisLogs@3
    #   displayName: 'üìä Publish Dependency Scan Results'
    #   inputs:
    #     ArtifactsName: 'DependencyScanResults'
    #     ArtifactsType: 'Container'
    #     ArtifactsPath: '$(Build.ArtifactStagingDirectory)'
    #   condition: always()
    #   continueOnError: true

    # Check for build warnings
    #- pwsh: |
    #    Write-Host "üî® Analyzing build output for warnings and errors..."
    #    $buildOutput = dotnet build --configuration $(buildConfiguration) --verbosity normal 2>&1
    #    $warnings = $buildOutput | Select-String -Pattern "warning"
    #    $errors = $buildOutput | Select-String -Pattern "error"
    #    
    #    if ($errors) {
    #      Write-Host "‚ùå Build errors found:"
    #      $errors | ForEach-Object { Write-Host "  $_" }
    #      Write-Host "Please fix errors before merging."
    #      exit 1
    #    }
    #    
    #    if ($warnings) {
    #      Write-Host "‚ö†Ô∏è Build warnings found:"
    #      $warnings | ForEach-Object { Write-Host "  $_" }
    #      Write-Host "Please review and fix warnings if possible."
    #    } else {
    #      Write-Host "‚úÖ No build warnings found"
    #    }
    #  displayName: 'üîç Check Build Warnings & Errors'

    # Security scan - check for hardcoded secrets and security issues
    - pwsh: |
        Write-Host "=========================================="
        Write-Host "üîí SECURITY SCAN - CODE SECURITY CHECKS"
        Write-Host "=========================================="
        
        $securityIssues = @()
        $criticalIssues = @()
        $warningIssues = @()
        
        # Files to scan (exclude build outputs and dependencies)
        $filesToScan = Get-ChildItem -Path . -Include *.cs,*.json,*.config,*.cshtml,*.js,*.ts -Recurse | 
            Where-Object { 
                $_.FullName -notlike "*\bin\*" -and 
                $_.FullName -notlike "*\obj\*" -and 
                $_.FullName -notlike "*\node_modules\*" -and
                $_.FullName -notlike "*\packages\*" -and
                $_.FullName -notlike "*\.git\*"
            }
        
        Write-Host "Scanning $($filesToScan.Count) files for security issues..."
        Write-Host ""
        
        # Security patterns to detect
        $secretPatterns = @{
            "API Key" = @(
                "api[_-]?key\s*[=:]\s*['""]?[a-zA-Z0-9_\-]{20,}['""]?",
                "sk_live_[a-zA-Z0-9]{32,}",
                "sk_test_[a-zA-Z0-9]{32,}",
                "AKIA[0-9A-Z]{16}",
                "ghp_[a-zA-Z0-9]{36}",
                "gho_[a-zA-Z0-9]{36}",
                "ghu_[a-zA-Z0-9]{36}"
            )
            "Password" = @(
                "password\s*[=:]\s*['""]?[^'""\s]{6,}['""]?",
                "pwd\s*[=:]\s*['""]?[^'""\s]{6,}['""]?",
                "passwd\s*[=:]\s*['""]?[^'""\s]{6,}['""]?",
                "pass\s*[=:]\s*['""]?[^'""\s]{6,}['""]?"
            )
            "Connection String" = @(
                "connectionstring\s*[=:]\s*['""]?[^'""]{20,}['""]?",
                "connection\s*string\s*[=:]\s*['""]?[^'""]{20,}['""]?",
                "connectionstring\s*[=:]\s*['""]?.*password.*['""]?",
                "connectionstring\s*[=:]\s*['""]?.*pwd.*['""]?"
            )
            "JWT Secret" = @(
                "jwt[_-]?secret\s*[=:]\s*['""]?[^'""]{20,}['""]?",
                "secret[_-]?key\s*[=:]\s*['""]?[^'""]{20,}['""]?",
                "jwt[_-]?key\s*[=:]\s*['""]?[^'""]{20,}['""]?"
            )
            "AWS Credentials" = @(
                "aws[_-]?access[_-]?key",
                "aws[_-]?secret[_-]?key",
                "AKIA[0-9A-Z]{16}",
                "wJalrXUtnFEMI"
            )
            "Azure Key" = @(
                "accountkey\s*[=:]\s*['""]?[^'""]{20,}['""]?",
                "DefaultEndpointsProtocol",
                "AccountKey=[^'""\s]{20,}"
            )
            "Private Key" = @(
                "-----BEGIN.*PRIVATE KEY-----",
                "-----BEGIN RSA PRIVATE KEY-----",
                "-----BEGIN OPENSSH PRIVATE KEY-----",
                "-----BEGIN EC PRIVATE KEY-----"
            )
            "Certificate" = @(
                "certificate\s*[=:]\s*['""]?[^'""]{20,}['""]?",
                "thumbprint\s*[=:]\s*['""]?[^'""]{20,}['""]?",
                "-----BEGIN CERTIFICATE-----"
            )
            "OAuth Secret" = @(
                "oauth[_-]?secret\s*[=:]\s*['""]?[^'""]{20,}['""]?",
                "client[_-]?secret\s*[=:]\s*['""]?[^'""]{20,}['""]?",
                "GOCSPX-[a-zA-Z0-9_-]{40,}"
            )
            "Encryption Key" = @(
                "encryption[_-]?key\s*[=:]\s*['""]?[^'""]{20,}['""]?",
                "aes[_-]?key\s*[=:]\s*['""]?[^'""]{20,}['""]?",
                "decryption[_-]?key\s*[=:]\s*['""]?[^'""]{20,}['""]?"
            )
            "Database Credentials" = @(
                "database[_-]?password\s*[=:]\s*['""]?[^'""]{6,}['""]?",
                "db[_-]?password\s*[=:]\s*['""]?[^'""]{6,}['""]?",
                "sql[_-]?password\s*[=:]\s*['""]?[^'""]{6,}['""]?"
            )
        }
        
        # Critical security patterns (will fail the build)
        $criticalPatterns = @(
            "-----BEGIN.*PRIVATE KEY-----",
            "sk_live_",
            "AKIA[0-9A-Z]{16}",
            "ghp_[a-zA-Z0-9]{36}",
            "password\s*[=:]\s*['""]?[^'""\s]{8,}['""]?"
        )
        
        foreach ($file in $filesToScan) {
            try {
                $content = Get-Content $file.FullName -Raw -ErrorAction SilentlyContinue
                if ($content) {
                    $relativePath = $file.FullName.Replace((Get-Location).Path + "\", "")
                    
                    # Check for critical issues
                    foreach ($pattern in $criticalPatterns) {
                        if ($content -match $pattern -and $relativePath -notlike "*BadSecurity*" -and $relativePath -notlike "*BadCode*") {
                            $lineNumber = ($content.Substring(0, $content.IndexOf($matches[0])).Split("`n").Count)
                            $criticalIssues += "‚ùå CRITICAL: Potential secret found in $relativePath (line ~$lineNumber)"
                        }
                    }
                    
                    # Check for all security patterns
                    foreach ($patternType in $secretPatterns.Keys) {
                        foreach ($pattern in $secretPatterns[$patternType]) {
                            if ($content -match $pattern -and $relativePath -notlike "*BadSecurity*" -and $relativePath -notlike "*BadCode*") {
                                $lineNumber = ($content.Substring(0, $content.IndexOf($matches[0])).Split("`n").Count)
                                $warningIssues += "‚ö†Ô∏è WARNING: $patternType found in $relativePath (line ~$lineNumber)"
                            }
                        }
                    }
                }
            } catch {
                # Skip files that can't be read
            }
        }
        
        # Check for intentional test files
        $badSecurityFiles = Get-ChildItem -Path . -Filter "*BadSecurity*" -Recurse | 
            Where-Object { $_.FullName -notlike "*\bin\*" -and $_.FullName -notlike "*\obj\*" }
        
        if ($badSecurityFiles) {
            Write-Host "‚ÑπÔ∏è Found intentional security test files:"
            $badSecurityFiles | ForEach-Object { Write-Host "  - $($_.FullName)" }
            Write-Host ""
        }
        
        # Report results
        Write-Host "=========================================="
        Write-Host "SECURITY SCAN RESULTS"
        Write-Host "=========================================="
        
        if ($criticalIssues.Count -gt 0) {
            Write-Host "‚ùå CRITICAL SECURITY ISSUES FOUND: $($criticalIssues.Count)"
            $criticalIssues | ForEach-Object { Write-Host "  $_" }
            Write-Host ""
            Write-Host "üö® CRITICAL: Hardcoded secrets detected! These must be removed before merging."
            Write-Host "   Use Azure Key Vault, User Secrets, or Environment Variables instead."
            Write-Host ""
            $securityIssues += $criticalIssues
        }
        
        if ($warningIssues.Count -gt 0) {
            Write-Host "‚ö†Ô∏è SECURITY WARNINGS FOUND: $($warningIssues.Count)"
            $warningIssues | ForEach-Object { Write-Host "  $_" }
            Write-Host ""
            Write-Host "‚ö†Ô∏è Please review these potential security issues."
            Write-Host ""
            $securityIssues += $warningIssues
        }
        
        if ($securityIssues.Count -eq 0) {
            Write-Host "‚úÖ No obvious security issues detected in source code"
            Write-Host ""
        }
        
        Write-Host "=========================================="
        
        # Fail the build if critical issues are found (it is disabled due to testing purposes)
        # if ($criticalIssues.Count -gt 0) {
        #     Write-Host "‚ùå Build failed due to critical security issues!"
        #     exit 1
        # }
      displayName: 'üîí Security Scan - Hardcoded Secrets'

    # Check for vulnerable and deprecated NuGet packages
    - pwsh: |
        Write-Host "=========================================="
        Write-Host "üì¶ NUGET PACKAGE SECURITY CHECK"
        Write-Host "=========================================="
        Write-Host "Checking for vulnerable and deprecated packages..."
        Write-Host ""
        
        $hasVulnerabilities = $false
        $hasDeprecated = $false
        $vulnerabilityCount = 0
        
        # First, restore packages to ensure we have the latest vulnerability data
        Write-Host "üì¶ Restoring packages to get latest vulnerability information..."
        dotnet restore --verbosity quiet 2>&1 | Out-Null
        Write-Host ""
        
        # Check for vulnerable packages
        Write-Host "üîç Scanning for vulnerable packages..."
        try {
          $vulnOutput = dotnet list package --vulnerable --include-transitive 2>&1 | Out-String
          
          # Check if output contains vulnerability indicators
          if ($vulnOutput -match "vulnerable|CVE-\d{4}-\d+|severity|High|Critical|Medium") {
            Write-Host "‚ùå VULNERABLE PACKAGES FOUND:"
            Write-Host ""
            
            # Display the full output
            $vulnOutput -split "`n" | ForEach-Object {
              $line = $_.Trim()
              if ($line -and $line -notmatch "^The following|^Project|^Top-level|^Transitive") {
                if ($line -match "CVE|vulnerable|severity|High|Critical") {
                  Write-Host "  ‚ùå $line"
                  $vulnerabilityCount++
                } elseif ($line -match "^\s*[A-Za-z]") {
                  Write-Host "  ‚ö†Ô∏è $line"
                }
              }
            }
            
            # Also try to get structured output
            $vulnJson = dotnet list package --vulnerable --include-transitive --format json 2>&1
            if ($vulnJson -match "vulnerable" -and $LASTEXITCODE -eq 0) {
              Write-Host ""
              Write-Host "Detailed vulnerability information:"
              Write-Host $vulnJson
            }
            
            Write-Host ""
            Write-Host "üö® ACTION REQUIRED: Update or remove vulnerable packages!"
            Write-Host "   Run: dotnet list package --vulnerable --include-transitive"
            Write-Host "   Then update packages using: dotnet add package <PackageName> --version <SafeVersion>"
            Write-Host "   Or use: dotnet add package <PackageName> --version latest"
            Write-Host ""
            $hasVulnerabilities = $true
          } else {
            Write-Host "‚úÖ No vulnerable packages found"
            Write-Host ""
          }
        } catch {
          Write-Host "‚ö†Ô∏è Could not check for vulnerable packages: $_"
          Write-Host "   This might be due to network issues or NuGet feed problems"
          Write-Host ""
        }
        
        # Check for deprecated packages
        Write-Host "üîç Scanning for deprecated packages..."
        try {
          $depOutput = dotnet list package --deprecated --include-transitive 2>&1 | Out-String
          
          # Check if output contains deprecation indicators
          if ($depOutput -match "deprecated|warning|deprecation") {
            Write-Host "‚ö†Ô∏è DEPRECATED PACKAGES FOUND:"
            Write-Host ""
            
            # Display the full output
            $depOutput -split "`n" | ForEach-Object {
              $line = $_.Trim()
              if ($line -and $line -notmatch "^The following|^Project|^Top-level|^Transitive") {
                if ($line -match "deprecated|deprecation") {
                  Write-Host "  ‚ö†Ô∏è $line"
                } elseif ($line -match "^\s*[A-Za-z]") {
                  Write-Host "  ‚ÑπÔ∏è $line"
                }
              }
            }
            
            Write-Host ""
            Write-Host "‚ö†Ô∏è ACTION RECOMMENDED: Update deprecated packages to supported versions"
            Write-Host "   Run: dotnet list package --deprecated --include-transitive"
            Write-Host "   Then update: dotnet add package <PackageName> --version <LatestVersion>"
            Write-Host ""
            $hasDeprecated = $true
          } else {
            Write-Host "‚úÖ No deprecated packages found"
            Write-Host ""
          }
        } catch {
          Write-Host "‚ö†Ô∏è Could not check for deprecated packages: $_"
          Write-Host ""
        }
        
        # Summary
        Write-Host "=========================================="
        Write-Host "NUGET PACKAGE SECURITY SUMMARY"
        Write-Host "=========================================="
        
        if ($hasVulnerabilities) {
          Write-Host "‚ùå Vulnerable packages detected - BUILD WILL FAIL"
          Write-Host "   Found $vulnerabilityCount potential vulnerability(ies)"
          Write-Host ""
          Write-Host "To fix:"
          Write-Host "1. Review vulnerable packages: dotnet list package --vulnerable --include-transitive"
          Write-Host "2. Check for updates: dotnet list package --outdated"
          Write-Host "3. Update to safe versions: dotnet add package <PackageName> --version <SafeVersion>"
          Write-Host "4. Or remove packages if no longer needed"
          Write-Host "5. Rebuild and verify: dotnet build"
          Write-Host ""
          # exit 1
        } elseif ($hasDeprecated) {
          Write-Host "‚ö†Ô∏è Deprecated packages found (non-blocking)"
          Write-Host "   Consider updating to supported versions to avoid future issues"
        } else {
          Write-Host "‚úÖ All packages are up-to-date and secure"
        }
        
        Write-Host "=========================================="
      displayName: 'üì¶ NuGet Package Security Check'

    # Code analysis - check for common issues
    - pwsh: |
        Write-Host "üìä Running code analysis..."
        
        # Check for project structure
        $projects = Get-ChildItem -Path . -Filter "*.csproj" -Recurse | Where-Object { $_.FullName -notlike "*\bin\*" -and $_.FullName -notlike "*\obj\*" }
        Write-Host "Found $($projects.Count) project file(s)"
        
        # Check for solution file
        $solutions = Get-ChildItem -Path . -Filter "*.sln" -Recurse
        if ($solutions) {
          Write-Host "‚úÖ Solution file(s) found: $($solutions.Name -join ', ')"
        } else {
          Write-Host "‚ö†Ô∏è No solution file found"
        }
        
        # Check for test projects (informational only)
        $testProjects = $projects | Where-Object { $_.FullName -like "*Test*" -or $_.FullName -like "*test*" }
        if ($testProjects) {
          Write-Host "‚ÑπÔ∏è Found $($testProjects.Count) test project(s) (not executing)"
        }
      displayName: 'üìä Code Structure Analysis'

    # Validate code compiles
    - pwsh: |
        Write-Host "‚úÖ Code compilation verified (passed in Build stage)"
        Write-Host "‚úÖ All projects compile successfully"
      displayName: '‚úÖ Compilation Validation'

    # Summary
    - pwsh: |
        Write-Host "=========================================="
        Write-Host "‚úÖ CODE QUALITY VALIDATION COMPLETE"
        Write-Host "=========================================="
        Write-Host "‚úì Code compiles successfully"
        Write-Host "‚úì Build warnings/errors checked"
        Write-Host "‚úì Gitleaks secret scanning completed"
        Write-Host "‚úì Security scan completed"
        Write-Host "‚úì NuGet package security checked"
        Write-Host "‚úì Code structure validated"
        Write-Host "‚úì Ready for Azure DevOps review"
        Write-Host "=========================================="
        
        # Use environment variables only - these are set by Azure DevOps for PR builds
        $prNumber = $env:SYSTEM_PULLREQUEST_PULLREQUESTNUMBER
        $prTargetBranch = $env:SYSTEM_PULLREQUEST_TARGETBRANCH
        
        if ($prNumber -and $prNumber -ne "") {
          Write-Host "Azure DevOps PR: $prNumber"
          if ($prTargetBranch -and $prTargetBranch -ne "") {
            Write-Host "Branch: $(Build.SourceBranchName) -> $prTargetBranch"
          } else {
            Write-Host "Source Branch: $(Build.SourceBranchName)"
          }
        } else {
          Write-Host "Source Branch: $(Build.SourceBranchName)"
        }
        Write-Host "=========================================="
      displayName: 'üìã Quality Check Summary'

- stage: ContractTests
  displayName: 'ü§ù Contract Tests (Pact Broker)'
  dependsOn: Build
  condition: succeeded()
  jobs:
  - job: PactTests
    displayName: 'Pact Contract Testing'
    variables:
      # =============================================================================
      # PACT BROKER CONFIGURATION
      # =============================================================================
      # Set these as pipeline variables (Pipelines > Edit > Variables)
      #
      # OPTION A: Self-Hosted Pact Broker (Basic Auth)
      #   - PactBrokerUrl: http://your-broker-host:9292
      #   - PactBrokerUsername: admin (mark as secret)
      #   - PactBrokerPassword: admin (mark as secret)
      #
      # OPTION B: PactFlow (Token Auth)
      #   - PactBrokerUrl: https://yourorg.pactflow.io
      #   - PactBrokerToken: your-api-token (mark as secret)
      #
      # Both options use the same PactBrokerUrl variable
      # =============================================================================
      PactBrokerUrl: 'https://pact-broker.orangeisland-078e5d22.centralus.azurecontainerapps.io/"
      PactBrokerUsername: 'admin'                  
      PactBrokerPassword: 'admin123!'

      PACT_BROKER_BASE_URL: $(PactBrokerUrl)
      # PactFlow (token auth)
      PACT_BROKER_TOKEN: $(PactBrokerToken)
      # Self-hosted (basic auth)
      PACT_BROKER_USERNAME: $(PactBrokerUsername)
      PACT_BROKER_PASSWORD: $(PactBrokerPassword)
      # Provider configuration
      PROVIDER_VERSION: $(Build.BuildId)
      PUBLISH_VERIFICATION_RESULTS: 'true'
    steps:
    - task: UseDotNet@2
      inputs:
        packageType: 'sdk'
        version: '8.x'
      displayName: '‚öôÔ∏è Setup .NET SDK'
        
    - task: Cache@2
      inputs:
        key: 'nuget | "$(Agent.OS)" | **/*.csproj'
        restoreKeys: |
          nuget | "$(Agent.OS)"
        path: $(NUGET_PACKAGES)
      displayName: '‚ö° Cache NuGet packages'

    - pwsh: |
        Write-Host "=========================================="
        Write-Host "PACT CONTRACT TESTING"
        Write-Host "=========================================="
        Write-Host "Running consumer-driven contract tests..."
        Write-Host "Build ID: $(Build.BuildId)"
        Write-Host "Branch: $(Build.SourceBranchName)"
        Write-Host ""
        
        $brokerUrl = $env:PACT_BROKER_BASE_URL
        $brokerToken = $env:PACT_BROKER_TOKEN
        $brokerUsername = $env:PACT_BROKER_USERNAME
        
        if ($brokerUrl) {
          Write-Host "Pact Broker: $brokerUrl"
          if ($brokerToken) {
            Write-Host "Auth: Token (PactFlow)"
          } elseif ($brokerUsername) {
            Write-Host "Auth: Basic Auth (Self-hosted)"
          }
        } else {
          Write-Host "[!] Pact Broker not configured - using local files only"
          Write-Host ""
          Write-Host "To enable Pact Broker integration, set pipeline variables:"
          Write-Host "  For Self-Hosted: PactBrokerUrl, PactBrokerUsername, PactBrokerPassword"
          Write-Host "  For PactFlow: PactBrokerUrl, PactBrokerToken"
        }
        Write-Host ""
      displayName: 'üìã Contract Testing Info'
      env:
        PACT_BROKER_BASE_URL: $(PACT_BROKER_BASE_URL)
        PACT_BROKER_TOKEN: $(PACT_BROKER_TOKEN)
        PACT_BROKER_USERNAME: $(PACT_BROKER_USERNAME)

    # Restore test projects
    - script: |
        dotnet restore tests/OrderService.Contract.Tests/OrderService.Contract.Tests.csproj
        dotnet restore tests/InventoryService.Contract.Tests/InventoryService.Contract.Tests.csproj
      displayName: 'üì¶ Restore Contract Test Projects'

    # Run Consumer Tests (generates pact files)
    - script: dotnet test tests/OrderService.Contract.Tests/OrderService.Contract.Tests.csproj --filter "FullyQualifiedName~OrderClientTests" --logger "trx;LogFileName=order_consumer_results.trx" --no-restore
      displayName: 'üß™ Run Order Consumer Tests'
      continueOnError: false

    - script: dotnet test tests/InventoryService.Contract.Tests/InventoryService.Contract.Tests.csproj --filter "FullyQualifiedName~InventoryClientTests" --logger "trx;LogFileName=inventory_consumer_results.trx" --no-restore
      displayName: 'üß™ Run Inventory Consumer Tests'
      continueOnError: false

    # Publish Pacts to Broker (supports both PactFlow and Self-hosted)
    - pwsh: |
        $brokerUrl = $env:PACT_BROKER_BASE_URL
        $brokerToken = $env:PACT_BROKER_TOKEN
        $brokerUsername = $env:PACT_BROKER_USERNAME
        $brokerPassword = $env:PACT_BROKER_PASSWORD
        
        if ([string]::IsNullOrEmpty($brokerUrl)) {
          Write-Host "[!] Pact Broker URL not configured. Skipping pact publish."
          exit 0
        }
        
        # Use the publish-pacts.ps1 script which supports both auth methods
        .\publish-pacts.ps1 -Version "$(Build.BuildId)" -Branch "$(Build.SourceBranchName)"
        
      displayName: 'üì§ Publish Pacts to Broker'
      env:
        PACT_BROKER_BASE_URL: $(PACT_BROKER_BASE_URL)
        PACT_BROKER_TOKEN: $(PACT_BROKER_TOKEN)
        PACT_BROKER_USERNAME: $(PACT_BROKER_USERNAME)
        PACT_BROKER_PASSWORD: $(PACT_BROKER_PASSWORD)
      condition: and(succeeded(), ne(variables['PACT_BROKER_BASE_URL'], ''))
      continueOnError: true

    # Run Provider Tests (verifies pact contracts from broker or local files)
    - script: dotnet test tests/OrderService.Contract.Tests/OrderService.Contract.Tests.csproj --filter "FullyQualifiedName~OrderApiProviderTests" --logger "trx;LogFileName=order_provider_results.trx" --no-restore
      displayName: 'üß™ Run Order Provider Tests'
      env:
        PACT_BROKER_BASE_URL: $(PACT_BROKER_BASE_URL)
        PACT_BROKER_TOKEN: $(PACT_BROKER_TOKEN)
        PACT_BROKER_USERNAME: $(PACT_BROKER_USERNAME)
        PACT_BROKER_PASSWORD: $(PACT_BROKER_PASSWORD)
        PROVIDER_VERSION: $(PROVIDER_VERSION)
        PUBLISH_VERIFICATION_RESULTS: $(PUBLISH_VERIFICATION_RESULTS)
      continueOnError: false

    - script: dotnet test tests/InventoryService.Contract.Tests/InventoryService.Contract.Tests.csproj --filter "FullyQualifiedName~InventoryApiProviderTests" --logger "trx;LogFileName=inventory_provider_results.trx" --no-restore
      displayName: 'üß™ Run Inventory Provider Tests'
      env:
        PACT_BROKER_BASE_URL: $(PACT_BROKER_BASE_URL)
        PACT_BROKER_TOKEN: $(PACT_BROKER_TOKEN)
        PACT_BROKER_USERNAME: $(PACT_BROKER_USERNAME)
        PACT_BROKER_PASSWORD: $(PACT_BROKER_PASSWORD)
        PROVIDER_VERSION: $(PROVIDER_VERSION)
        PUBLISH_VERIFICATION_RESULTS: $(PUBLISH_VERIFICATION_RESULTS)
      continueOnError: false

    # Can-I-Deploy check (uses REST API script)
    - pwsh: |
        $brokerUrl = $env:PACT_BROKER_BASE_URL
        
        if ([string]::IsNullOrEmpty($brokerUrl)) {
          Write-Host "[!] Pact Broker not configured. Skipping can-i-deploy check."
          exit 0
        }
        
        # Use the can-i-deploy.ps1 script which supports both auth methods
        .\can-i-deploy.ps1 -Pacticipant "OrderServiceApi" -Version "$(Build.BuildId)" -To "production"
        
      displayName: 'üö¶ Can-I-Deploy Check'
      env:
        PACT_BROKER_BASE_URL: $(PACT_BROKER_BASE_URL)
        PACT_BROKER_TOKEN: $(PACT_BROKER_TOKEN)
        PACT_BROKER_USERNAME: $(PACT_BROKER_USERNAME)
        PACT_BROKER_PASSWORD: $(PACT_BROKER_PASSWORD)
      condition: and(succeeded(), ne(variables['PACT_BROKER_BASE_URL'], ''))
      continueOnError: true
      
    - task: PublishTestResults@2
      inputs:
        testResultsFormat: 'VSTest'
        testResultsFiles: '**/*_results.trx'
        mergeTestResults: true
        testRunTitle: 'Pact Contract Tests'
      displayName: 'üìä Publish Contract Test Results'
      condition: always()

    - pwsh: |
        Write-Host "=========================================="
        Write-Host "[OK] CONTRACT TESTING COMPLETE"
        Write-Host "=========================================="
        Write-Host "[OK] Consumer contracts generated"
        Write-Host "[OK] Provider contracts verified"
        Write-Host "[OK] API compatibility confirmed"
        
        $brokerUrl = $env:PACT_BROKER_BASE_URL
        if ($brokerUrl) {
          Write-Host "[OK] Contracts published to Pact Broker"
          Write-Host "     View contracts at: $brokerUrl"
        }
        Write-Host "=========================================="
      displayName: 'üìã Contract Testing Summary'
      env:
        PACT_BROKER_BASE_URL: $(PACT_BROKER_BASE_URL)
      condition: succeeded()

